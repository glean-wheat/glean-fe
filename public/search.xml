<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>通过Blob将一个字符串保存为各种文件</title>
      <link href="2020/10/15/Blob-%E9%80%9A%E8%BF%87Blob%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6/"/>
      <url>2020/10/15/Blob-%E9%80%9A%E8%BF%87Blob%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>结合 <a href="https://github.com/zerolab-fe/one-question-per-day/issues/78">#78</a>文章中讲到了将服务端给的二进制文件直接进行保存；二进制文件中包含了文件类型和内容；如果实现纯前端保存一段字符串为.txt、.js、css 文件呢。其他的文件类型都是可以的；<br>自己封装了一个方法，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> downloadFileByBlob = <span class="function">(<span class="params">blobUrl, filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> eleLink = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  eleLink.download = filename</span><br><span class="line">  eleLink.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">  eleLink.href = blobUrl</span><br><span class="line">  <span class="comment">// 触发点击</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(eleLink)</span><br><span class="line">  eleLink.click()</span><br><span class="line">  <span class="comment">// 然后移除</span></span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(eleLink)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> downFile = <span class="function">(<span class="params">config, type, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> blobContent = <span class="keyword">new</span> Blob([config], &#123;</span><br><span class="line">    type: type</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> blobUrl = <span class="built_in">window</span>.URL.createObjectURL(blobContent)</span><br><span class="line">  downloadFileByBlob(blobUrl, name)</span><br><span class="line">  <span class="comment">// 需要注意</span></span><br><span class="line">  <span class="built_in">window</span>.URL.revokeObjectURL(blobUrl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> downFiles = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; jsCode, cssCode &#125; = &#123;</span><br><span class="line">    title: <span class="string">&#x27;文件名称&#x27;</span>,</span><br><span class="line">    jsCode: <span class="string">`const test =&#x27;hello word&#x27;`</span>,</span><br><span class="line">    cssCode: <span class="string">`.test&#123;</span></span><br><span class="line"><span class="string">                width:100px </span></span><br><span class="line"><span class="string">         &#125;`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  downFile(jsCode, <span class="string">&#x27;text/javascript&#x27;</span>, title + <span class="string">&#x27;.jsx&#x27;</span>) <span class="comment">// 根据文件类型；传入一个合适的 MIME 类型</span></span><br><span class="line">  downFile(cssCode, <span class="string">&#x27;text/css&#x27;</span>, title + <span class="string">&#x27;.scss&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在每次调用 createObjectURL() 方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法来释放。</p><p>浏览器在 document 卸载的时候，会自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。</p><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><p><a href="https://www.w3school.com.cn/media/media_mimeref.asp">MIME</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Blob </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>contenteditable 属性详解</title>
      <link href="2020/10/14/Contenteditable-%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/10/14/Contenteditable-%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在编写组件的时候遇到了一个问题，就是要求输入框的高度随着内容自动变高；textarea 本身肯定是不支持的；立刻就想到了 contenteditable 属性</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开头安利一个小技巧 在地址栏输入 data:text/html,</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">contenteditable</span>&gt;</span></span><br><span class="line">  这样浏览器就变成了编辑器</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关于-HTML-部分"><a href="#关于-HTML-部分" class="headerlink" title="关于 HTML 部分"></a>关于 HTML 部分</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span> <span class="attr">id</span>=<span class="string">&quot;editable&quot;</span>&gt;</span>这里面的内容是可以编辑的<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="script-部分"><a href="#script-部分" class="headerlink" title="script 部分"></a>script 部分</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> editorWrapper = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#editable&#x27;</span>)</span><br><span class="line">editorWrapper.onblur = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失去焦点&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.dir(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">editorWrapper.onfocus = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;获取焦点&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.dir(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">editorWrapper.oninput = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;模拟change事件&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.dir(e.target.innerHTML)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支持以下事件"><a href="#支持以下事件" class="headerlink" title="支持以下事件;"></a>支持以下事件;</h3><ul><li>当失去焦点时; <strong>editable.onblur=function(e){}</strong> 事件</li><li>当获取焦点时; <strong>editable.onfocus=function(e){}</strong> 事件</li><li>使用 oninput 来的代替 onChange 事件<br><strong>但是常用的 change 事件是不支持的;</strong></li></ul><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span> <span class="attr">id</span>=<span class="string">&quot;editable&quot;</span>&gt;</span>这里面的内容是可以编辑的<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> editorWrapper = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#editable&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    editorWrapper.onblur = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;失去焦点&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.dir(e)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    editorWrapper.onfocus = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;获取焦点&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.dir(e)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    editorWrapper.oninput = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;模拟change事件&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.dir(e.target.innerHTML)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> contenteditable </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html中的DOM节点转成图片并上传</title>
      <link href="2020/10/14/Blob-Html%E4%B8%AD%E7%9A%84DOM%E8%8A%82%E7%82%B9%E8%BD%AC%E6%88%90%E5%9B%BE%E7%89%87%E5%B9%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>2020/10/14/Blob-Html%E4%B8%AD%E7%9A%84DOM%E8%8A%82%E7%82%B9%E8%BD%AC%E6%88%90%E5%9B%BE%E7%89%87%E5%B9%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在开发中遇到遇到将用户选取的节点区域，生成截图，并上传<br>实现起来比较容易，我在此分享给大家</p></blockquote><p>首先大家先要认识一下 <code>html2canvas</code> 这个库；<a href="http://html2canvas.hertzen.com/">文档地址</a>，整体使用起来是比较简单的<br>也可以继续深入研究，这个库的社区还是很活跃的。</p><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p>另外大家需要简单了解一下 Blob,一直以来，JS 都没有比较好的可以直接处理二进制的方法。而 Blob 的存在，允许我们可以通过 JS 直接操作二进制数据。</p><pre><code>一个Blob对象就是一个包含有只读原始数据的类文件对象。Blob对象中的数据并不一定得是JavaScript中的原生形式。File接口基于Blob，继承了Blob的功能,并且扩展支持了用户计算机上的本地文件。</code></pre><p>Blob 对象可以看做是存放二进制数据的容器，此外还可以通过 Blob 设置二进制数据的 MIME 类型</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">MDN 文档地址</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><code>npm i html2canvas --save</code><br><code>import html2canvas from &#39;html2canvas&#39;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;节点ID&#x27;</span>)</span><br><span class="line">html2canvas(box).then(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> base64Img = canvas.toDataURL()</span><br><span class="line">  <span class="comment">// 通过生成的base64 图片，将其转成Blob</span></span><br><span class="line">  <span class="keyword">const</span> filesImg = base64ToBlob(base64Img)</span><br><span class="line">  uploadImg(filesImg)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> base64ToBlob = <span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> parts = code.split(<span class="string">&#x27;;base64,&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> contentType = parts[<span class="number">0</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> raw = <span class="built_in">window</span>.atob(parts[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">let</span> rawLength = raw.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> uInt8Array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(rawLength)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rawLength; ++i) &#123;</span><br><span class="line">    uInt8Array[i] = raw.charCodeAt(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([uInt8Array], &#123; <span class="attr">type</span>: contentType &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uploadImg = <span class="function"><span class="params">filesImg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> param = <span class="keyword">new</span> FormData()</span><br><span class="line">  param.append(<span class="string">&#x27;file&#x27;</span>, filesImg, updataTypes)</span><br><span class="line">  <span class="comment">// 调用自己的上传  这样就行了</span></span><br><span class="line">  axios(<span class="string">&#x27;/upload&#x27;</span>, &#123;</span><br><span class="line">    type: <span class="string">&#x27;upload&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;file&#x27;</span>, <span class="comment">// 文件参数</span></span><br><span class="line">    data: param,</span><br><span class="line">    file: filesImg, <span class="comment">// 文件x/</span></span><br><span class="line">    params: &#123;</span><br><span class="line">      name: formValue.blockName</span><br><span class="line">    &#125;, <span class="comment">// 其他参数</span></span><br><span class="line">    withCredentials: <span class="literal">true</span>,</span><br><span class="line">    onUploadProgress: <span class="function"><span class="params">event</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;上传结果&#x27;</span>, res)</span><br><span class="line">    <span class="comment">// 上传进度</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Blob </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Blob实现前端下载文件</title>
      <link href="2020/10/14/Blob-%E9%80%9A%E8%BF%87Blob%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>2020/10/14/Blob-%E9%80%9A%E8%BF%87Blob%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在封装请求库的时候，想要把 download 方法也集成到自己的请求库中，自己想了一下下载的方式进行一下记录</p></blockquote><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p>先撸代码吧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> download = <span class="function">(<span class="params">options, host</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; filename = <span class="string">&#x27;未命名&#x27;</span> &#125; = options</span><br><span class="line">  <span class="keyword">const</span> url = host ? host + options.url : options.url</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置类型，防止出现乱码</span></span><br><span class="line">  <span class="built_in">Object</span>.assign(options, &#123; <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span> &#125;)</span><br><span class="line">  axios(&#123; ...options, url &#125;).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; downloadSuccess &#125; = options</span><br><span class="line">      <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="built_in">window</span>.Blob([res.data])</span><br><span class="line">      <span class="keyword">const</span> downloadElement = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">      <span class="keyword">const</span> href = <span class="built_in">window</span>.URL.createObjectURL(blob) <span class="comment">// 创建下载的链接</span></span><br><span class="line">      downloadElement.href = href</span><br><span class="line">      downloadElement.download = filename <span class="comment">// 下载后文件名</span></span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(downloadElement)</span><br><span class="line">      downloadElement.click() <span class="comment">// 点击下载</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(downloadElement) <span class="comment">// 下载完成移除元素</span></span><br><span class="line">      <span class="built_in">window</span>.URL.revokeObjectURL(href) <span class="comment">// 释放blob对象</span></span><br><span class="line">      downloadSuccess &amp;&amp; downloadSuccess(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; downloadFail &#125; = options</span><br><span class="line">      downloadFail &amp;&amp; downloadFail(error)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> download</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL">https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications">https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL">https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL</a></li></ul><h3 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h3><p>这个方法也是可以在直接下载二进制的文件的，这个就不详细介绍了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blob </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨项目区块复用方案实践</title>
      <link href="2020/10/14/Bit-%E8%B7%A8%E9%A1%B9%E7%9B%AE%E5%8C%BA%E5%9D%97%E5%A4%8D%E7%94%A8%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5/"/>
      <url>2020/10/14/Bit-%E8%B7%A8%E9%A1%B9%E7%9B%AE%E5%8C%BA%E5%9D%97%E5%A4%8D%E7%94%A8%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在平时的前端业务开发中，常常需要使用一些组件库里的组件开发页面。然而单单这些组件一般很难完全满足业务需求，还需要针对不同的业务场景进行开发添加业务逻辑。当随着开发的前端项目数量越来越多，就会发现很多业务场景会经常遇到，而且基本大同小异，可能只需要修改少量的代码，原来开发的代码就可以在新的项目中使用。</p><p>例如账号绑定手机号这个场景，除了使用了 input、button 等组件等，还要添加很多例如校验手机号、设置倒计时、接口校验验证码等逻辑。如果输入验证码的样式比较特别，可能还会有基于通用 input 组件二次封装出专门针对验证码的输入框。当再次遇到类似绑定手机号的需求时，大部分前端往往会直接从原有的项目中拷贝一份到新的项目，然后做一些微调即可。</p><p>这方式可能会遇到以下几个问题：</p><ul><li><strong>可复用的业务场景代码散落在形形色色的前端业务项目中，信息不互通，跨项目搜索很难</strong>。<br>往往需要问些资历比较深的开发同事，才能知道某个业务场景在哪个项目中开发过。如果刚来的开发同事并不知道之前已经开发过，而是自己闷头从零开发，就会导致开发资源浪费的问题。</li><li><strong>相似的业务场景在不同的业务项目里有着不同的代码实现，无法做到统一标准，共同实现一个最佳实践</strong>。<br>平时开发时经常会有这样一个问题：在不同的业务项目中都编写过相似的业务场景的代码，但都是不同人各自维护的，之间也没有过交流。就会导致后面新的项目开发相似的业务场景时，面临有多个版本代码的选择。无法做到共同维护一个版本代码，并不断优化和改造，最终实现在这个业务场景的最佳实践。</li></ul><p>后面的内容就是笔者为了解决上述问题，而开发的跨项目区块复用平台的实践总结。讲到这里读者可能会有个疑问：什么是区块？为什么是区块复用而不是组件复用？</p><p>为了解答这个问题，我们先明确下这些概念的定义，下面直接引用阿里飞冰相关的定义：</p><p>组件（component）：功能比较确定同时复杂度较高，例如用户选择器、地址选择器等，项目中只需要引入对应的 npm 包即可，项目不关心也无法修改组件内部的代码，只能通过组件定义的 props 控制。</p><p>区块（block）：一般是一个 UI 模块，使用区块时会将区块代码拷贝到项目代码中，项目里可以对区块代码进行任何改动，因此区块后续的升级也不会对项目有任何影响，这是区块跟业务组件的最大区别。</p><p>对于组件，笔者所在公司有一个非常完善的流程了：将可复用的代码抽象成基础/业务组件，然后走 npm 包发布的流程，并展示在内建的组件平台上。使用者只需要在平台上找到自己需要的组件，然后通过私有 npm 源下载到项目的依赖中即可使用。</p><p>而对于区块，一般很难抽象成组件并集成到 npm 包里，使用时往往需要直接修改区块的源码。而针对区块的复用，目前并没有合适的工具可以使用，所以才会主要针对区块实现了一个可共享复用的平台。特别说明一下，本文的区块除了包括 UI 相关的代码，也包括一些可复用的 utils 方法等等。</p><p>这个平台是基于 <a href="https://github.com/teambit/bit">Bit</a> 开发的，所以在阐述区块复用平台的实现之前，需要先介绍下 Bit 的原理。</p><h2 id="Bit-基本原理"><a href="#Bit-基本原理" class="headerlink" title="Bit 基本原理"></a>Bit 基本原理</h2><p>为了避免读者的困扰，这里先提前声明一下，在这个小节里会经常出现 <code>组件</code> 这一词，读者可以理解成 <code>Bit 组件</code>–即可复用的代码片段。原因是 Bit 本身并没有区分组件和区块，凡是可复用的代码片段都可以通过 Bit 来实现复用，只是笔者主要用它来实现区块共享而已。下面是 Bit 的原理图：</p><p><img src="https://camo.githubusercontent.com/55572ce94daee1f3683a29ae01f2f3b62ac65889/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30392f31322f7432736e4850784d6c4236557076592e706e67" alt="Bit 原理图.png"></p><p>Bit 是一个用于跨项目组件协作的开源 CLI 工具。使用 Bit 将分散在各个项目中的组件转化可复用的 Package，并可以跨项目使用。</p><p>你可以设置自己的用于组件协作的服务，也可以使用 <a href="https://bit.dev/">Bit.dev cloud</a> 托管组件，用于私有或共有组件的共享。</p><p>上面是 Bit 官方文档对 Bit 的定义，读者可能会觉得和 Git 有点相似。Bit 的确在实现中受到 Git 很大启发。不过区别在于 Git 是以文件为维度的，而 Bit 是以组件为维度。想了解更多内容可以点击 <a href="https://docs.bit.dev/docs/quick-start">Bit Docs</a> 。</p><h3 id="Bit-组件的定义和要素"><a href="#Bit-组件的定义和要素" class="headerlink" title="Bit 组件的定义和要素"></a>Bit 组件的定义和要素</h3><p>关于上面定义中的提到 Bit 组件，Bit 也给出了自己的定义：</p><ul><li><strong>一个 React, Vue or Angular 组件</strong></li><li><strong>公共样式文件 (例如 CSS, SCSS)</strong></li><li><strong>可复用的方法</strong></li></ul><p>针对每个组件 Bit 主要存储以下三个要素：</p><ul><li><strong>源代码（包括代码、测试和文档）</strong></li><li><strong>依赖图谱</strong><br>当添加文件到 Bit 组件时，Bit 会分析该文件的引入的依赖（例如代码中的 import 或 require 语句）。依赖图谱使组件独立于项目存在，可以跨项目移动且不丢失任何引用。<br>需要注意的是，这里追踪的依赖项只包含使用 NPM 安装的依赖和安装的 Bit 组件。也就是说项目中直接引入的本地文件不被包含在依赖项内，例如 <code>import &#123; computeXXX &#125; from &#39;../utils&#39;</code>。不过不必担心，当在本地执行发布组件到远程的命令时，Bit 会检测引入的本地文件是否也被追踪，没有的话是无法发布的。</li><li><strong>工具和配置</strong><br>Bit 还会将组件特有的工具和配置保存下来，比如组件使用的编译器和测试工具等。</li></ul><p>下面这张图生动的呈现了一个 Bit 组件的构成要素。</p><p><img src="https://camo.githubusercontent.com/9c2e6ccc97cc91dc677ef068615d6f3b54d1a1e3/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30392f32372f5a6244487838316e4b494a477a516a2e706e67" alt="Bit-component.png"></p><h3 id="Bit-组件的生命周期"><a href="#Bit-组件的生命周期" class="headerlink" title="Bit 组件的生命周期"></a>Bit 组件的生命周期</h3><p>Bit 组件的发布和使用都是通过开源的 CLI 工具 <a href="https://www.npmjs.com/package/bit-bin">bit-bin</a> 来实现的，读者可以在自己的电脑上全局安装这个 npm 包，尝试用它发布个组件体验下。</p><h4 id="发布组件到远程仓库"><a href="#发布组件到远程仓库" class="headerlink" title="发布组件到远程仓库"></a>发布组件到远程仓库</h4><ul><li><strong>Track</strong>: 通过指定组成组件的文件，来初始化一个 Bit 组件。同时这些文件的内容修改会被追踪。具体命令：<code>bit add src/bindPhone/xxx -i bindPhone</code>。</li><li><strong>Version</strong>: 给组件标记版本，会将这个版本的组件的元数据和文件内容固化下来。具体命令：<code>bit tag bindPhone 1.0.0</code>。</li><li><strong>Export</strong>: 导出组件会为组件创建一个唯一的 ID。这个唯一 ID 包含了 Remote Scope 和本地组件名称。export 指令会将组件的元数据和文件内容的拷贝推送到远程仓库。具体命令：<code>bit export [remoteScopeName]</code>。</li></ul><h4 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h4><p>当组件被推送到服务器上的远程仓库，其他本地的 Bit WorkSpace 就可以使用这个组件了。使用的方式包括了两种：一种是 Install 方式–将组件作为一个常规的 npm 包安装到 node_modules 中，另一种方式是 Import 方式–将组件的源代码以及依赖等信息下载到本地。</p><p>读者可以再结合下面这张图来理解上面 Bit 组件生命周期的内容。</p><p><img src="https://camo.githubusercontent.com/56db808214a9b3e88ffe618e132bed56c8e0d3ab/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30392f32372f35715554504144534a4e61496243562e706e67" alt="Bit-CLI.png"></p><h3 id="Bit-部分概念解释"><a href="#Bit-部分概念解释" class="headerlink" title="Bit 部分概念解释"></a>Bit 部分概念解释</h3><h4 id="Workspace（工作区）"><a href="#Workspace（工作区）" class="headerlink" title="Workspace（工作区）"></a>Workspace（工作区）</h4><p>当在前端业务项目中执行 <code>bit init</code> 命令时，整个业务项目就变成了 workspace（工作区），类似 Git 中的工作区概念。</p><h4 id="Scope（仓库）"><a href="#Scope（仓库）" class="headerlink" title="Scope（仓库）"></a>Scope（仓库）</h4><p>当在前端业务项目中执行 <code>bit init</code> 命令时，会生成一个 <code>.bit</code>目录，这个目录就是 bit scope（仓库），类似 Git 的 .git 目录就是 git repository（仓库）。</p><p>一个 scope 可以存在或者不存在 Bit 工作区中，组件通过 <code>bit export</code> 和 <code>bit import</code> 命令在不同的 scope 之间传递，另外也可以使用 <code>bit tag</code> 和 <code>bit checkout</code> 命令将单个版本的组件从本地 scope（仓库） 和本地 workspace（工作区） 之间进行转换。</p><p>组件在 scope 中是采用 CAS(content addressable storage 内容寻址存储) 存储的，关于 scope 的存储的原理后面会详细阐述。Bit 受到了 Git 的机制很大的启发，如果读者对 Git 熟悉的话，就会更容易理解 Bit。</p><h4 id="Remote-Scope（远程仓库）"><a href="#Remote-Scope（远程仓库）" class="headerlink" title="Remote Scope（远程仓库）"></a>Remote Scope（远程仓库）</h4><p>Remote scope 是保存在服务器上的，也可以叫 bare scope，因为这个 scope（仓库） 是在 workspace（工作区） 之外的。Remote scope 是主要是用于共享组件的，也就是组件的导出/导入的地方。</p><h2 id="实现跨项目区块复用方案"><a href="#实现跨项目区块复用方案" class="headerlink" title="实现跨项目区块复用方案"></a>实现跨项目区块复用方案</h2><p>通过上面的介绍，相信读者对 Bit 已经有了初步认知，其实笔者认为 Bit 非常适合跨项目区块复用平台的最主要的原因在于：发布者无需类似发布 npm 一样，需要单独创建项目并发布，而是<strong>可以直接在业务项目中发布可复用的区块代码</strong>。这一点非常适用区块的<strong>很难抽象且代码在项目中可以任意改动的特点</strong>。</p><p>那么剩下需要思考的问题就是如何在 Bit 基础上实现整个跨项目区块复用平台方案。下面这张图是整个方案的架构图，下面的小节会针对架构图中的不同部分分别做阐述。</p><p><img src="https://camo.githubusercontent.com/4dd72bba83b25a142a077ed374123b6be74e2732/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30392f31332f56754155764e777833533166486f5a2e706e67" alt="区块复用平台基本原理"></p><h3 id="Bit-远程仓库（Bit-Remote-Scope）"><a href="#Bit-远程仓库（Bit-Remote-Scope）" class="headerlink" title="Bit 远程仓库（Bit Remote Scope）"></a>Bit 远程仓库（Bit Remote Scope）</h3><p>Bit 官方已经提供了在服务器上部署远程仓库的方案，可以在远程服务器上执行 Bit 的<code>bit init --bare</code> 命令初始化一个远程仓库，或者直接部署 Bit 官方提供的 Docker 镜像 <a href="https://github.com/teambit/bit-docker">bit-docker</a>。</p><p>部署完远程仓库后，使用者就可以通过 ssh 协议将本地仓库的区块代码上传到远程仓库中，或者从远程仓库中下载区块代码。</p><p>更多细节可以参考官方文档 <a href="https://docs.bit.dev/docs/bit-server">bit-server</a>。</p><h3 id="Bit-CLI"><a href="#Bit-CLI" class="headerlink" title="Bit CLI"></a>Bit CLI</h3><p>上个小节中提到的上传和下载区块代码的操作都是通过 Bit 开源的 CLI 工具 <a href="https://www.npmjs.com/package/bit-bin">bit-bin</a> 实现的，读者可以直接在实际开发中使用。</p><p>不过如果有一些特定的需求，例如在执行 <code>bit import</code> 下载区块代码时，需要记录下载次数到区块平台中等，就需要定制 <a href="https://www.npmjs.com/package/bit-bin">bit-bin</a>。对此笔者建议直接克隆一份 Bit 源码 <a href="https://github.com/teambit/bit">bit</a>，然后进行二次定制开发，并通过在公司内部发布私有 npm 包的方式提供开发使用。</p><h3 id="区块平台"><a href="#区块平台" class="headerlink" title="区块平台"></a>区块平台</h3><p>经过上面的操作，区块代码已经托管在服务器上的远程仓库（Remote Scope）中，但区块使用者还无法很直观地通过查看区块代码构建出来的视图来选择区块，也无法对区块代码进行在线调试查看效果，这对区块的使用造成了很大困扰。</p><p>而官方提供的门户站点 <a href="https://bit.dev/">bit.dev</a> 虽然有这些功能但并没有开源，所以我们需要做一个类似功能的站点。通过分析 <a href="https://bit.dev/">bit.dev</a> 站点的功能，可以发现站点实现中的两个关键点：</p><ol><li>实时构建区块代码，然后对构建出的页面截图，展示在区块列表中。并且可以在线调试区块源码，然后实时看到调试后的构建结果；</li><li>从远程仓库存储的文件中解析出某个区块的数据（源码、依赖等等），以便在区块平台中使用。</li></ol><p>关于第一点，主要需要一个在线 IDE 的支持，对此笔者之前已经总结了一篇文章–<a href="https://github.com/mcuking/blog/issues/86">搭建一个属于自己的在线 IDE</a>，这里就不再赘述了。接下来主要阐述下第二点的实现。</p><h4 id="从远程仓库中解析区块数据"><a href="#从远程仓库中解析区块数据" class="headerlink" title="从远程仓库中解析区块数据"></a>从远程仓库中解析区块数据</h4><p>还记得之前有提到 Bit 的 Scope（仓库） 是采用 CAS（content addressable storage 内容寻址存储） 存储 Bit 组件的文件吗？接下来我们就详细的介绍其中的原理。</p><p>经过对 Bit 源码的分析，我们发现 Bit 组件的文件存储和 Git 非常相似，所以首先了解下 Git 是怎么做文件存储的，这里主要参考了文章 <a href="https://zhaohuabing.com/post/2019-01-21-git/">Git 内部存储原理</a> 的内容：</p><p>Git 的本质是一个文件系统，其工作空间中的所有文件的历史版本以及提交记录(Commit)、branch、tag 等信息都是以文件对象的方式保存在 .git 目录中的。在 .git 下的 objects 目录下可能会看下面这类文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.git/objects</span><br><span class="line">├── <span class="number">06</span></span><br><span class="line">│   └── <span class="number">5</span>bcad11008c5e958ff743f2445551e05561f59</span><br><span class="line">├── <span class="number">3</span>b</span><br><span class="line">│   └── <span class="number">18e512</span>dba79e4c8300dd08aeb37f8e728b8dad</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure><p>Git Objects 目录中的文件类型主要有以下三种：</p><ul><li><strong>Commit</strong>: Commit 对象，记录了一个 Version 的所有目录和文件信息</li><li><strong>Tree</strong>: 目录对象，记录了该目录下包含那些目录和文件信息</li><li><strong>Blob</strong>: 文件对象，记录了文件内容</li></ul><p>而 Git Objects 是通过下面的方式处理并存储在 Git 内部的文件系统中的：</p><ol><li>首先创建一个 header，header 的值为 “对象类型 内容长度\0”；</li><li>将 header 和文件内容连接起来，计算得到其 SHA-1 hash 值（40 个十六进制的数字组成的字符串）；</li><li>将连接得到的内容采用 zlib 压缩；</li><li>将压缩后的内容写入到以 “hash 值前两位命令的目录/hash 值后 38 位命令的文件” 中。</li></ol><p>在 Bit 源码中， Bit Scope 中的 objects 文件也分成以下几种类型：</p><ul><li><strong>Component</strong>: 记录了 Bit 组件的相关信息，包括区块名称、历史版本等</li><li><strong>Version</strong>: 记录了每次发布的版本信息，例如这次版本的包含的文件、依赖、发布者邮箱/用户名、发布时间等</li><li><strong>Source</strong>: 记录了文件内容</li><li><strong>Symlink</strong>: 暂时无用</li><li><strong>Scope</strong>: 暂时无用</li></ul><p>而 Bit Objects 在处理和存储上面这些信息的方式也和 Git 大同小异：</p><ol><li>首先根据文件内容计算得到其 SHA-1 hash 值（40 个十六进制的数字组成的字符串）；</li><li>然后创建一个 header，header 的值为 “对象类型 文件内容的 SHA-1 hash 值 内容长度\0”；</li><li>将 header 和文件内容连接起来；</li><li>将连接得到的内容采用 zlib 压缩；</li><li>将压缩后的内容写入到以 “hash 值前两位命令的目录/hash 值后 38 位命令的文件” 中。</li></ol><p>区别在于两点：一个是 Git 是根据 <code>header + 文件内容</code> 两者相加组成的完整内容计算的 SHA-1 hash 值，而 Bit 仅仅根据文件内容计算 SHA-1 hash 值；另一个点是 Bit 的 header 中还额外包括文件内容的 SHA-1 hash 值。</p><p>既然我们知道了数据是如何被处理和存储成这些文件，那么就可以反过来从这些文件中解析出这些数据，下面就是解析文件的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SPACE_DELIMITER = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NULL_BYTE = <span class="string">&#x27;\u0000&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inflate = (buffer) =&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&#123;</span><br><span class="line">        zlib.inflate(buffer, (err, res) =&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);</span><br><span class="line">            <span class="keyword">return</span> resolve(res);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象转化成 buffer    const buf = Buffer.from(JSON.stringify(obj));</span></span><br><span class="line"><span class="comment">// 将 buffer 转化成对象   const temp = JSON.parse(buf.toString());</span></span><br><span class="line"><span class="keyword">const</span> parse = (buffer) =&#123;</span><br><span class="line">    <span class="comment">// 使用分隔符号 &#x27;\u0000&#x27; 将文件内容分成 header 和 content 两部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> firstNullByteLocation = buffer.indexOf(NULL_BYTE);</span><br><span class="line">    <span class="comment">// 头部部分</span></span><br><span class="line">    <span class="keyword">const</span> headers = buffer.slice(<span class="number">0</span>, firstNullByteLocation).toString();</span><br><span class="line">    <span class="comment">// 内容部分</span></span><br><span class="line">    <span class="keyword">const</span> contents = buffer.slice(firstNullByteLocation + <span class="number">1</span>, buffer.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [type] = headers.split(SPACE_DELIMITER);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;file type is:&#x27;</span>, headers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;Source&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> contents.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(contents.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parseObject = <span class="keyword">async</span> (path) =&#123;</span><br><span class="line">    <span class="keyword">const</span> contents = <span class="keyword">await</span> fs</span><br><span class="line">        .readFile(path)</span><br><span class="line">        .then(fileContents =&#123;</span><br><span class="line">            <span class="keyword">return</span> inflate(fileContents);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(buffer =parse(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;file contents is:&#x27;</span>, contents);</span><br><span class="line">    <span class="keyword">return</span> contents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parseObject(<span class="string">&#x27;/Users/xxx/bit/common/objects/03/3cb8b37245cf0cfbde2495d5d88c1324234e96&#x27;</span>);</span><br></pre></td></tr></table></figure><p>然后就可以调用 parseObject 方法去解析不同类型文件的内容，例如 Component 文件的示例内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">  scope: <span class="string">&#x27;common&#x27;</span>,</span><br><span class="line">  versions: &#123;</span><br><span class="line">    <span class="string">&#x27;1.0.0&#x27;</span>: <span class="string">&#x27;4873cd3d4efdd585ee9a960bdfb16f2ee986ab14&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1.0.1&#x27;</span>: <span class="string">&#x27;e1e8280f56c5bfca8640e186f5667286b2023927&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  lang: <span class="string">&#x27;javascript&#x27;</span>,</span><br><span class="line">  deprecated: <span class="literal">false</span>,</span><br><span class="line">  bindingPrefix: <span class="string">&#x27;@bit&#x27;</span>,</span><br><span class="line">  remotes: [</span><br><span class="line">    &#123;</span><br><span class="line">      url: <span class="string">&#x27;file:///Users/xxx/bit/common&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;common&#x27;</span>,</span><br><span class="line">      date: <span class="string">&#x27;1599218799176&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Version 文件示例内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  files: [</span><br><span class="line">    &#123;</span><br><span class="line">      file: <span class="string">&#x27;0b8b28f212101ef236744a25bfa085a00d0e7a63&#x27;</span>,</span><br><span class="line">      relativePath: <span class="string">&#x27;src/components/button/index.js&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">      test: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  mainFile: <span class="string">&#x27;src/components/button/index.js&#x27;</span>,</span><br><span class="line">  bindingPrefix: <span class="string">&#x27;@bit&#x27;</span>,</span><br><span class="line">  log: &#123;</span><br><span class="line">    message: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    date: <span class="string">&#x27;1599218793164&#x27;</span>,</span><br><span class="line">    username: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    email: <span class="string">&#x27;xxx@xxx.com&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ci: &#123;&#125;,</span><br><span class="line">  docs: [],</span><br><span class="line">  dependencies: [],</span><br><span class="line">  devDependencies: [],</span><br><span class="line">  flattenedDependencies: [],</span><br><span class="line">  flattenedDevDependencies: [],</span><br><span class="line">  extensions: [],</span><br><span class="line">  packageDependencies: &#123; <span class="attr">react</span>: <span class="string">&#x27;^16.13.1&#x27;</span> &#125;,</span><br><span class="line">  devPackageDependencies: &#123;&#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Source 文件内容其实就是区块的源码，这里就不展示了。</p><p>接下来的分析中又发现本地 scope 中（即 .bit 目录中）的 index.json 文件中记录了 Bit 组件的对应的 Component 文件的 SHA-1 hash 值。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;[</span><br><span class="line">  &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">      scope: <span class="string">&#x27;common&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;button&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    isSymlink: <span class="literal">false</span>,</span><br><span class="line">    hash: <span class="string">&#x27;2179ca06272f0962fafd793abdf27a553fd9b418&#x27;</span> <span class="comment">// 对应组件的 Component 文件</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>根据以上分析到的知识点，我们就可以找出从远程仓库 Scope 的 Objects 中解析出我们需要的区块源代码的方法了，大致步骤如下：</p><ol><li>首先从 scope 中的 index.json 中找到对应区块名称，并获取到区块对应的 Component 文件的 hash 值；</li><li>使用上面的 parseObject 方法解析出 Component 文件的内容，并从 Component 文件内容中的 versions 字段找到区块最新版本对应的 Version 文件的 hash 值；</li><li>使用上面的 parseObject 方法解析出 Version 文件的内容，从 Version 文件内容中的 files 字段就可以找到该区块包含的所有源码文件名称、相对路径、hash 值等，从 dependencies、devDependencies 等字段中就可以获取区块所有的依赖；</li><li>将上个步骤中获取到的区块源代码/依赖等数据，按照一定的格式返回给区块平台即可。</li></ol><p>这样就达到了从 Bit 远程仓库中解析出某个区块的源码和依赖等数据，并返回给区块平台的目的。由于篇幅有限，具体代码就不在这里展示了。</p><p>到此整个架构的实践就已将介绍完了。当然在这个基础上还可以做很多有趣的事情，例如编写一个 VSCode 插件用于在编辑器右侧展示区块平台上的所有区块，用户可以搜索浏览区块，点击区块即可下载到项目中，并自动引入到代码里。效果如下图所示：</p><p><img src="https://camo.githubusercontent.com/2e72218162b41cd66cf45e328c961d8efd77ce09/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30392f32372f5857767449426f52616a78413754702e706e67" alt="区块 VSCode 插件"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>如果做个类比的话，区块复用平台就像冶金设备，而前端的业务项目就像一座座矿山，区块复用平台的使命就是从这么多前端项目中冶炼出有复用价值的金子–区块，并将这些金子直观地展示给开发者，使其尽可能复用这些区块，以提升开发效率。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>-<a href="https://ice.work/docs/materials/about">飞冰-关于物料</a></p><p>-<a href="https://zhaohuabing.com/post/2019-01-21-git/">Git 内部存储原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Bit </tag>
            
            <tag> 区块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebComponent 简单尝试</title>
      <link href="2020/10/12/WebComponent-%E7%AE%80%E5%8D%95%E5%B0%9D%E8%AF%95/"/>
      <url>2020/10/12/WebComponent-%E7%AE%80%E5%8D%95%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天我们要站在开发者和项目角度来聊聊 WebComponent，同样它也是一套技术的组合，能提供给开发者组件化开发的能力。</p></blockquote><p>那什么是组件化呢？其实组件化并没有一个明确的定义，不过这里我们可以使用 10 个字来形容什么是组件化，那就是：对内高内聚，对外低耦合。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。</p><p>可以说，程序员对组件化开发有着天生的需求，因为一个稍微复杂点的项目，就涉及到多人协作开发的问题，每个人负责的组件需要尽可能独立完成自己的功能，其组件的内部状态不能影响到别人的组件，在需要和其他组件交互的地方得提前协商好接口。通过组件化可以降低整个系统的耦合度，同时也降低程序员之间沟通复杂度，让系统变得更加易于维护。使用组件化能带来很多优势，所以很多语言天生就对组件化提供了很好的支持，比如 C/C++ 就可以很好地将功能封装成模块，无论是业务逻辑，还是基础功能，抑或是 UI，都能很好地将其组合在一起，实现组件内部的高度内聚、组件之间的低耦合。</p><p>大部分语言都能实现组件化，归根结底在于编程语言特性，大多数语言都有自己的函数级作用域、块级作用域和类，可以将内部的状态数据隐藏在作用域之下或者对象的内部，这样外部就无法访问了，然后通过约定好的接口和外部进行通信。</p><p>JavaScript 虽然有不少缺点，但是作为一门编程语言，它也能很好地实现组件化，毕竟有自己的函数级作用域和块级作用域，所以封装内部状态数据并提供接口给外部都是没有问题的。</p><p>既然 JavaScript 可以很好地实现组件化，那么我们所谈论的 WebComponent 到底又是什么呢？</p><p>阻碍前端组件化的因素在前端虽然 HTML、CSS 和 JavaScript 是强大的开发语言，但是在大型项目中维护起来会比较困难，如果在页面中嵌入第三方内容时，还需要确保第三方的内容样式不会影响到当前内容，同样也要确保当前的 DOM 不会影响到第三方的内容。所以要聊 WebComponent，得先看看 HTML 和 CSS 是如何阻碍前端组件化的，这里我们就通过下面这样一个简单的例子来分析下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">p &#123;</span><br><span class="line">      background-color: brown;</span><br><span class="line">      color: cornsilk</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;www.baidu.org&lt;/p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">p &#123;</span><br><span class="line">      background-color: red;</span><br><span class="line">      color: blue</span><br><span class="line">   &#125;</span><br><span class="line">&lt;p&gt;www.baidu.com&lt;/p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这两段代码分别实现了自己 p 标签的属性，如果两个人分别负责开发这两段代码的话，那么在测试阶段可能没有什么问题，不过当最终项目整合的时候，其中内部的 CSS 属性会影响到其他外部的 p 标签的，之所以会这样，是因为 CSS 是影响全局的</p><p>除了 CSS 的全局属性会阻碍组件化，DOM 也是阻碍组件化的一个因素，因为在页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM。所以使用 JavaScript 来实现组件化是没有问题的，但是 JavaScript 一旦遇上 CSS 和 DOM，那么就相当难办了。</p><h3 id="WebComponent-组件化开发"><a href="#WebComponent-组件化开发" class="headerlink" title="WebComponent 组件化开发"></a>WebComponent 组件化开发</h3><p>现在我们了解了 CSS 和 DOM 是阻碍组件化的两个因素，那要怎么解决呢？WebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。了解了这些，下面我们就结合具体代码来看看 WebComponent 是怎么实现组件化的。</p><p>前面我们说了，WebComponent 是一套技术的组合，具体涉及到了 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和 HTML templates（HTML 模板），详细内容你可以参考 MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components">相关链接</a>。</p><p>下面我们就来演示下这 3 个技术是怎么实现数据封装的，如下面代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">            一：定义模板</span><br><span class="line">            二：定义内部CSS样式</span><br><span class="line">            三：定义JavaScript行为</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;template id=<span class="string">&quot;geekbang-t&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            p &#123;</span><br><span class="line">                background-color: brown;</span><br><span class="line">                color: cornsilk</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            div &#123;</span><br><span class="line">                width: <span class="number">200</span>px;</span><br><span class="line">                background-color: bisque;</span><br><span class="line">                border: <span class="number">3</span>px solid chocolate;</span><br><span class="line">                border-radius: <span class="number">10</span>px;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;time.geekbang.org&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;time1.geekbang.org&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;inner log&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">GeekBang</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">            <span class="keyword">constructor</span>() &#123;</span><br><span class="line">                <span class="built_in">super</span>()</span><br><span class="line">                <span class="comment">//获取组件模板</span></span><br><span class="line">                <span class="keyword">const</span> content = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#geekbang-t&#x27;</span>).content</span><br><span class="line">                <span class="comment">//创建影子DOM节点</span></span><br><span class="line">                <span class="keyword">const</span> shadowDOM = <span class="built_in">this</span>.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;)</span><br><span class="line">                <span class="comment">//将模板添加到影子DOM上</span></span><br><span class="line">                shadowDOM.appendChild(content.cloneNode(<span class="literal">true</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        customElements.define(<span class="string">&#x27;geek-bang&#x27;</span>, GeekBang)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;geek-bang&gt;&lt;/geek-bang&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;time.geekbang.org&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;time1.geekbang.org&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;geek-bang&gt;&lt;/geek-bang&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>详细观察上面这段代码，我们可以得出：要使用 WebComponent，通常要实现下面三个步骤。</p><p>首先，使用 <strong>template 属性来创建模板</strong>。利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的 template 节点不会出现在布局树中，所以我们可以使用 template 来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。一般模板定义好之后，我们还需要在模板的内部定义样式信息。</p><p>其次，我们需要创建一个 <strong>GeekBang 的类</strong>。</p><p>在该类的构造函数中要完成三件事：</p><ul><li>查找模板内容；</li><li>创建影子 DOM；</li><li>再将模板添加到影子 DOM 上。</li></ul><p>上面最难理解的是<strong>影子 DOM</strong>，其实影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。总之，通过影子 DOM，我们就实现了 CSS 和元素的封装，在创建好封装影子 DOM 的类之后，我们就可以使用 <strong>customElements.define</strong> 来自定义元素了（可参考上述代码定义元素的方式）。</p><p>最后，就很简单了，可以像正常使用 HTML 元素一样使用该元素，如上述代码中的<code>&lt;geek-bang&gt;&lt;/geek-bang&gt;</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> WebComponent </tag>
            
            <tag> 组件化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebComponent 个人理解</title>
      <link href="2020/10/12/WebComponet-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
      <url>2020/10/12/WebComponet-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="接下来自己开始依照个人计划开始-WebComponent-相关技术的深入研究"><a href="#接下来自己开始依照个人计划开始-WebComponent-相关技术的深入研究" class="headerlink" title="接下来自己开始依照个人计划开始 WebComponent 相关技术的深入研究"></a>接下来自己开始依照个人计划开始 WebComponent 相关技术的深入研究</h3><p>Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。</p><hr><p>Web Component 的诞生本身是为了更加方便的去定义组件，它有着天然的样式隔离和作用域空间。这也符合了组件的最基本的特点：** 高内聚、低耦合 **。</p><p>一个好的组件库，本身肯定有着自己的样式管理、工具类管理等规范。根本目的就是要做的相互隔离，不受其他的样式和功能影响。但是实际的开发中，有些情况是避免不了的；复杂度、专属语法、性能消耗的代价。</p><p>一般在开发中大家都会对组件库进行定制化的模改；样式、字体大小等方面。这些都涉及到了样式方面的改动</p><hr><p>现代浏览器的 API 已经更新到你不需要使用一个框架就可以去创建一个可服用的组件。Custom Element 和 Shadow DOM 都可以让你去创造可复用的组件。</p><p>最早在 2011 年，Web Components 就已经是一个只需要使用 HTML、CSS、JavaScript 就可以创建可复用的组件被介绍给大家。这也意味着你可以不使用类似 React 和 Angular 的框架就可以创造组件。甚至，这些组件可以无缝的接入到这些框架中。</p><p>这么久以来第一次，我们可以只使用 HTML、CSS、JavaScript 来创建可以在任何现代浏览器运行的可复用组件。Web Components 现在已经被主要的浏览器的较新版本所支持。</p><p>Edge 将会在接下来的 19 版本提供支持。而对于那些旧的版本可以使用 polyfill 兼容至 IE11. 这意味着你可以在当下基本上任何浏览器甚至移动端使用 Web Components。</p><p>创造一个你定制的 HTML 标签，它将会继承 HTM 元素的所有属性，并且你可在任何支持的浏览器中通过简单的引入一个 script。所有的 HTML、CSS、JavaScript 将会在组件内部局部定义。 这个组件在你的浏览器开发工具中显示为一个单独个 HTML 标签，并且它的样式和行为都是完全在组件内进行，不需要工作区，框架和一些前置的转换。</p><p>是不是有些心动了；</p><p>Web Components 的一些主要功能：<br>未完。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> WebComponent </tag>
            
            <tag> 组件化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/11/hello-world/"/>
      <url>2020/10/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
